# Canonical Log Schemas

This document describes two generalized schemas used across Causal_Web log files.

## Diagnostic Per-Tick Schema

Diagnostic logs capture granular tick flow, emission decisions and failures. Despite varying payloads they all share a common wrapper generated by `GenericLogEntry`.

```
log_id: str            # unique entry id
tick: int              # simulation tick
timestamp: datetime    # creation time in UTC
correlation_id: str?   # optional grouping identifier used to group related events from the same causal thread
event_type: str        # name of the log file or event
payload: object        # log specific fields
```

Fields within `payload` differ per file (e.g. `node`, `phase`, `source`, `target`,
`reason`, `coherence`). Any information not covered by the common fields should
be stored inside this metadata object. Prefer flat key‑value pairs for `payload`
unless nested structures are required for clarity. Example entries:

```json
{
  "log_id": "log_1",
  "tick": 42,
  "timestamp": "2024-05-01T12:00:00Z",
  "event_type": "tick_emission_log",
  "payload": {"node_id": "n1", "phase": 1.57}
}
```

A failure case may look like this:

```json
{
  "log_id": "log_42",
  "tick": 105,
  "timestamp": "2024-05-01T12:10:00Z",
  "event_type": "tick_drop_log",
  "payload": {
    "source_id": "n5",
    "target_id": "n8",
    "reason": "magnitude_below_threshold",
    "magnitude": 0.003,
    "status": "dropped"
  }
}
```

## Event-Driven/Periodic Schema

Summary and phenomenon logs record higher level events or periodic metrics. They
follow a lighter structure:

```
tick: int?             # tick associated with the record when relevant
label: str             # identifier for the node, metric name or category
value: object          # measurement, list or mapping
metadata: object?      # optional additional context
```

`tick` is optional and omitted for pure summaries like `manifest.json` or other
records that are not tied to a specific simulation tick. `label` may indicate a
node id, metric name or categorical tag. If its meaning becomes ambiguous,
separate the label from the metric name using additional fields. `value`
contains the main data such as counts, state maps or diagnostics. Extra fields
(e.g. `origin`, `affected_nodes` or `confidence`) reside under `metadata`.

An example periodic log entry might look like:

```json
{
  "tick": 150,
  "label": "coherence_drift",
  "value": {
    "R1": 0.84,
    "R2": 0.29
  },
  "metadata": {
    "threshold": 0.2,
    "layer": 2
  }
}
```

These schemas unify log processing by distinguishing fine-grained diagnostic
records from coarser periodic summaries.

## Log file fields
The following lists describe the JSON keys recorded in each output file.

#### `boundary_interaction_log.json`
- event-driven record with `tick`, `label` as the affected node and
  `value` containing the tick `origin`.

#### `bridge_decay_log.json`
- `tick` – tick when decay occurred.
- `bridge` – bridge identifier.
- `strength` – remaining strength after decay.
- `duration` – ticks since the bridge was last active.

#### `bridge_dynamics_log.json`
- `bridge_id` – unique bridge id.
- `source` – source node id.
- `target` – target node id.
- `event` – state change name.
- `tick` – tick of the event.
- `seeded` – whether created by the initial graph.
- `conditions` – optional context such as phase difference.

#### `bridge_reformation_log.json`
- `tick` – tick when the bridge reformed.
- `bridge` – id of the bridge.
- `coherence` – average coherence at reformation.

#### `bridge_rupture_log.json`
- `tick` – tick of the rupture.
- `bridge` – bridge id.
- `source` – originating node id.
- `target` – target node id.
- `reason` – rupture cause.
- `coherence` – coherence value at failure.
- `fatigue` – accumulated fatigue level.

#### `bridge_state_log.json`
- keyed by tick with nested bridge entries:
  - `active` – whether the bridge is enabled.
  - `last_activation` – most recent activation tick.
  - `last_rupture_tick` – tick of the last rupture or `null`.
  - `last_reform_tick` – tick of the last recovery or `null`.
  - `coherence_at_reform` – coherence when last reformed.
  - `trust_score` – current trust value.
  - `reinforcement` – reinforcement streak count.

#### `classicalization_map.json`
- keyed by tick with `{node: bool}` indicating if a node is classicalised.

#### `cluster_influence_matrix.json`
- periodic entry labelled `cluster_influence_matrix` mapping
  `{ "regionA->regionB": count }` between regions based on edges.

#### `cluster_log.json`
- keyed by tick with hierarchical cluster assignments per level.

#### `coherence_log.json`
- keyed by tick with `{node: coherence}` values.

#### `coherence_velocity_log.json`
- keyed by tick with `{node: delta}` change since the previous tick.

#### `collapse_chain_log.json`
- `tick` – tick when propagation occurred.
- `source` – collapsing node.
- `collapsed` – list of nodes with depth information.
- `collapsed_entity` – id of the initiating node.
- `children_spawned` – ids of any spawned nodes.

#### `collapse_front_log.json`
- either `{tick, node, event}` for collapse start events or
  `{tick, source, chain}` describing propagation depth.

#### `connectivity_log.json`
- `{node: {edges_out, edges_in, bridges, total}}` summary at load time.

#### `curvature_log.json`
- keyed by tick with per-edge delay adjustments:
  - `delta_f` – frequency difference.
  - `curved_delay` – resulting delay value.

#### `curvature_map.json`
- list of periodic records using `tick`, `label` set to
  `curvature_map` and `value` containing `{source, target, delay}`
  entries for visualisation.

#### `decoherence_log.json`
- keyed by tick with `{node: decoherence}` values.

#### `event_log.json`
- records bridge events with fields:
  - `tick`, `event_type`, `bridge_id`, `source`, `target`,
    `coherence_at_event`.

#### `global_diagnostics.json`
- event-driven entry labelled `global_diagnostics` containing
  `coherence_stability_score`, `entropy_delta`,
  `collapse_resilience_index` and `network_adaptivity_index`.

#### `inspection_log.json`
- list of superposition inspections with keys:
  - `tick`, `node`, `contributors`, `interference_result`,
    `collapsed`, `bridge_status`.

#### `interference_log.json`
- keyed by tick with `{node: superposition_count}`.

#### `law_drift_log.json`
- `tick`, `node` and the updated `new_refractory_period`.

#### `law_wave_log.json`
- keyed by tick with `{node: frequency}` values.

#### `law_wave_event`
- emitted when a law wave propagates with `{origin, affected}`.

#### `stable_frequency_log.json`
- keyed by tick mapping nodes to stabilised law-wave frequencies.

#### `layer_transition_log.json`
- `tick`, `node`, source `from` layer, destination `to` layer and `trace_id`.

#### `layer_transition_events.json`
- counts of layer transitions summarised as
  `{node: {layer: count}}`.

#### `magnitude_failure_log.json`
- `node`, `magnitude`, `threshold` and number of `phases` when a tick fails.

#### `meta_node_ticks.json`
- keyed by tick with `{meta_id: [member_nodes]}` entries.

#### `node_emergence_log.json`
- new node details including `id`, `tick`, `parents`,
  `origin_type`, `generation_tick`, `sigma_phi` and `phase_confidence_index`.

#### `node_state_log.json`
- keyed by tick containing:
  - `type` – node type per id.
  - `credit` – coherence credit values.
  - `debt` – decoherence debt values.

#### `node_state_map.json`
- records transitions with `node`, `from` and `to` state identifiers.

#### `observer_disagreement_log.json`
- `tick`, `observer` and `diff` between observation and reality.

#### `observer_perceived_field.json`
- `tick`, `observer` and the inferred `state` per node.

#### `propagation_failure_log.json`
- heterogeneous records describing why propagation failed. Common
  fields include `node` or `parent`, failure `type` and `reason`.

#### `proper_time_log.json`
- keyed by tick with `{node: subjective_ticks}` values.

#### `refraction_log.json`
- rerouting information containing `tick` and either
  `recursion_from` or `from`/`via`/`to` paths.

#### `regional_pressure_map.json`
- periodic entry labelled `regional_pressure_map` with averaged
  decoherence pressure per region.

#### `should_tick_log.json`
- decisions from `should_tick` with `node` and `reason`.

#### `simulation_state.json`
- `paused`, `stopped` and optional `graph_snapshot` path.

#### `structural_growth_log.json`
- per tick record of node counts and SIP/CSP success/failure totals.

#### `tick_delivery_log.json`
- `source`, `node_id` and `stored_phase` for incoming ticks.


#### `tick_drop_log.json`
- dropped tick info: `node`, `reason`, `coherence`, `node_type`.

#### `tick_emission_log.json`
- emitted ticks with `node_id` and `phase`.

#### `tick_evaluation_log.json`
- evaluation outcome fields:
  `node`, `coherence`, `threshold`, `refractory`, `fired`, `reason`.

#### `tick_propagation_log.json`
- `source`, `target`, `arrival_time` and propagated `phase`.

#### `tick_seed_log.json`
- seeder actions recording `node`, `phase`, `strategy`,
  `coherence`, `threshold`, `success` and optional `failure_reason`.

#### `tick_trace.json`
- complete graph snapshot including nodes, edges, bridges and tick history.

#### `void_node_map.json`
- periodic entry labelled `void_node_map` listing node ids with no
  connections.

#### `manifest.json`
- summary produced by `bundle_run.py` containing run metadata such as
  `run_id`, `timestamp`, tick counts, collapse statistics and diagnostics.

#### `interpretation_log.json`
- aggregated metrics produced by the interpreter. Keys may include
  `curvature`, `collapse`, `coherence`, `law_wave`, `decoherence`,
  `layer_transitions`, `rerouting`, `node_state_transitions`, `clusters`,
  `bridges`, `law_drift`, `meta_nodes`, `tick_counts`, `layer_summary`,
  `inspection_events` and `console`.

#### `causal_explanations.json`
- explanation events with `tick_range`, `affected_nodes`,
  `origin` rule and textual `explanation`.

#### `causal_summary.txt`
- human readable narrative of the explanation events.

#### `explanation_graph.json`
- periodic record labelled `explanation_graph` containing a DAG with
  nodes (`id`, `tick`, `type`, `node`, `description`) and edges
  (`source`, `target`, `label`).

#### `causal_chains.json`
- event-driven entry labelled `causal_chains` containing each chain's
  `root_event`, `chain` steps and overall `confidence`.

#### `causal_timeline.json`
- periodic log labelled `causal_timeline` where each item stores
  `tick` and a list of event descriptors.

#### `cwt_console.txt`
- captured console output from the run.

The raw logs (`tick_trace.json`, `coherence_log.json`, `event_log.json`, etc.) remain in `output/` for detailed inspection. For convenience, running `bundle_run.py` packages the important files with a manifest describing the run.
